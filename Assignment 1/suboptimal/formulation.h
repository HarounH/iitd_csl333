#ifndef FORMULATION_H
	#define FORMULATION_H

#include <vector>
#include <deque>
#include <string>
#include <iostream>
#include <unordered_map>
#include <random>
#include <algorithm>

using namespace std;

enum INIT_TYPE { RANDOM = 0 , STATS = 1 , RANDOM_UNIFORM , RANDOM_CHI2};

//Change the following two values to alter the number of longer/shorter length children generated by getDeterministicNBD.
#define LONGER_LENGTH_CHILDREN 5
#define SHORTER_LENGTH_CHILDREN 5

//Formulation requires that we minimize 
class SeqState {
public:
	int length; 					 	//stores the length of the strings of this state.
	double cost; 						//Functions as energy too.
	//vector< deque<char> > sequences; 	//deque allows for Faster Swaps and stuff. - Not necessary.
	vector< vector<int> > dashPos;		//Encapsulates the entire state. NEEDS TO BE SORTED.
		//dashPos[i] is the number of sequence character's before the ith dash. ab-cd would have dashpos = [2].

	//Comparision stuff, just in case its needed.
	bool operator>=(const SeqState& rhs) const {return cost >= rhs.cost; }
	bool operator<=(const SeqState& rhs) const {return cost <= rhs.cost; } //Just use the correct heap.
	bool operator==(const SeqState& rhs) const {return cost == rhs.cost; }
	bool operator>(const SeqState& rhs) const {return cost >  rhs.cost; }
	bool operator<(const SeqState& rhs) const {return cost <  rhs.cost; }
};

class SeqProblem {
public:
	double clockTime;
	double TIME_BUFFER;	
	//Cost Related
	vector< vector<double> > MC; 	//matching costs
	double CC; 						//Conversion cost
	//Alphabet Related
	int aSize;
	vector<char> alphabet;
	int longerLengthChildren;
	int shorterLengthChildren;
	unordered_map< char , int > charToInt;
	//Sequence Related
	int k;
	vector<string> sequences; //Input sequences
	vector<int> stringLengths;
	int sumOfLengths;
	int minimumFinalLength;
	int maximumFinalLength;
	SeqState initialState;
	vector<SeqState> initialStates;
	std::random_device rd;
	std::mt19937 engine;

	SeqProblem();

	//Misc Functions
	void print();
	void printState( SeqState& state);
	//Initialization Functions
	void followSchedule(SeqState& best);
	void initialize(INIT_TYPE initMode); 						//Initializes into Problem::initialState.
	void initialize(INIT_TYPE initMode, int numStates);
	void initializeInto(INIT_TYPE initMode , SeqState& state , SeqState& prevBest , int restarts); 	//Initialize into state 
	void initializeInto(INIT_TYPE initMode , vector<SeqState>& states, int numStates); 	//Initialize into state 
	void randomInit(vector<int>& vec, int x, int start, int end);		//Randomly fill vector with x values between start and end
	//Functions required by search.
	void getNBD( SeqState& n , vector<SeqState>& nbd); //NeighBourhooD - NBD
		void getNBD_singleDashMove( SeqState& n , vector<SeqState>& nbd);
		void getNBD_differentLengths(SeqState& n , vector<SeqState>& nbd);
	double evalCost( SeqState& state);
	void setChildCost_singleDash( SeqState& parent ,  SeqState& child , int stringIDX_1);
};

SeqProblem::SeqProblem() : engine(rd())
{}

#endif